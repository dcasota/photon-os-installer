#!/usr/bin/env python3

import getopt
import json
import os
import sys
import tempfile
import subprocess
from photon_installer import tdnf


def usage():
    print(
f"""Usage: {sys.argv[0]}
       -p <package_list.json> (required)
       -s <source repo URL> (optional if "upstream-repos" is set in <package_list.json>, otherwise required)
       -d <destination repo dir> (default is 'cherry-picks')
"""
    )

def main():
    src_repo_url = None
    base_repo_urls = []
    dst_repo_dir = "cherry-picks"
    pkglist_file = None
    do_requires = False

    try:
        opts, args = getopt.getopt(sys.argv[1:], "d:hs:p:", longopts=["base-repo-url=", "requires", "source-repo-url="])
    except:
        print (f"{sys.argv[0]}: invalid option")
        sys.exit(2)

    for o, a in opts:
        if o in ["--base-repo-url"]:
            base_repo_urls.append(a)
        elif o in ["-p"]:
            pkglist_file = a
        elif o in ["--requires"]:
            do_requires = True
        elif o in ["-d"]:
            dst_repo_dir = a
        elif o in ["-s", "--source-repo-url"]:
            src_repo_url = a
        elif o in ["-h"]:
            usage()
            sys.exit(0)
        else:
            assert False, f"unhandled option {o}"

    assert pkglist_file is not None, f"need to specify package list file ({sys.argv[0]} -p <file>)"
    assert dst_repo_dir is not None, f"need to specify output directory ({sys.argv[0]} -d <directory>)"

    if not pkglist_file.startswith('/'):
        pkglist_file = os.path.join(os.getcwd(), pkglist_file)

    with open(pkglist_file, "rt") as f:
        try:
            plf_json = json.load(f)
        except json.decoder.JSONDecodeError as e:
            print(f"failed to read json file {pkglist_file}")
            print(f"json decode failed at line {e.lineno}, at:")
            print(f"'{e.doc[e.pos:]}'")
            raise e

    upstream_repos = plf_json.get('upstream-repos', {})
    if src_repo_url is not None:
        upstream_repos['_src_repo'] = {'baseurl' : src_repo_url, 'enabled': 1, 'gpgcheck': 0}
    for _, ur in upstream_repos.items():
        if 'priority' not in ur:
            ur['priority'] = 75

    assert upstream_repos, "no upstream repository specified - use `-s <source repo URL>` or add in the packages file"

    base_repos = plf_json.get('base-repos', {})
    for i, br_url in enumerate(base_repo_urls):
        # make sure priority is higher (lower value), so this gets prefered over upstream_repos
        base_repos[f'_base_repo_{i}'] = {'baseurl' : br_url, 'enabled': 1, 'gpgcheck': 0, 'priority': 25}

    packages = []
    if 'packages' in plf_json:
        packages.extend(plf_json['packages'])

    # enforce full nevr
    for p in packages:
        assert "=" in p, f"package {p} does not have a version"
        n, v = p.split("=")
        assert "-" in v, f"package {p} does not have a full version/release"

    repos_dir = tempfile.mkdtemp(prefix="reposdir-")
    tdnf.create_repo_conf(upstream_repos, reposdir=repos_dir)
    tdnf.create_repo_conf(base_repos, reposdir=repos_dir)

    os.makedirs(dst_repo_dir, exist_ok=True)

    # if the list is empty skip tdnf download to prevent failure,
    # and create just an empty repository
    if packages:
        # setting installroot is a hack to make it fetch already installed packages,
        # packages will be downloaded to --downloaddir
        install_root = tempfile.mkdtemp(prefix="installroot-")
        tdnf_inst = tdnf.Tdnf(reposdir=repos_dir, installroot=install_root, releasever="5.0")

        if do_requires:
            pkgs_all = []
            # "tdnf install" command but with "--asumeno", will show all
            # packages that are required in json output, but not
            # install/download anything
            retval, tdnf_out = tdnf_inst.run(["--assumeno", "--downloadonly", f"--downloaddir={dst_repo_dir}", "--alldeps", "install"] + packages)
            assert retval == 0, "tdnf failed while getting requirements"

            # we should only have 'Install' in json output because the installroot is empty
            pkginfo_list = tdnf_out['Install']

            # filter for packages that are from _src_repo
            for pkginfo in pkginfo_list:
                if pkginfo['Repo'] in upstream_repos:
                    name = pkginfo['Name']
                    evr = pkginfo['Evr']
                    pkgs_all.append(f"{name}={evr}")

            # make list unique, also account for corner case where cherry
            # picked package is in base repo and therefore filtered out
            packages = list(set(pkgs_all + packages))

        retval, tdnf_out = tdnf_inst.run(["--downloadonly", f"--downloaddir={dst_repo_dir}", "--nodeps", "install"] + packages)
        assert retval == 0, "tdnf failed while downloading packages"

    subprocess.run(["createrepo", dst_repo_dir], check=True)


if __name__ == "__main__":
    main()
